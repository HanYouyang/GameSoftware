作业 7

作业截止时间
周五晚 22:00

交作业方式：
本次作业 7 需要在项目中新建一个 axe7 目录，上交如下文件
axe7/x16asm.py
axe7/x16vm.py

请注意，不要上传多余的文件到仓库，使用 sourcetree 来确保这一点

根据本作业的描述，实现下面两个函数
x16asm.machine_code(asm_code: str)
x16vm.run(memory: List[int])

新的汇编语言资料如下：
我们把 AxePU 升级为 AxePU16（简称 x16）
x16 有如下寄存器
注意，机器码中的寄存器都是用一字节表示的，但是寄存器里面存储的数据是 16 位
00000000 ; pa（program address） 寄存器
00010000 ; a1
00100000 ; a2
00110000 ; a3
01000000 ; c1，保存比较结果的寄存器。0 表示小于，1 表示相等，2 表示大于
01010000 ; f1 寄存器，保存当前寄存器暂存状态的内存地址

我们需要的指令如下
注意，指令也都是用一字节表示的
下面的指令都是操作单字节的，它们作用于寄存器的时候，只会影响寄存器的低 8 位，高 8 位会被清零（高低 8 位怎么模拟你自己定，无所谓，对程序来说它是透明的）
00000000 ; set 指令，用于给寄存器存一个 8 位数字（寄存器高 8 位会清零，以下同理）
00000001 ; load 指令，用于把内存中的一个数字读到寄存器中
;load @101 a2
00000010 ; add 指令，加的是寄存器低 8 位
00000011 ; save 指令，用手把寄存器的一个数字存到内存地址中，注意这里的内存地址是一个 16 位的数字
00000100 ; compare 指令，用于比较 a1 a2 的大小并且保存结果到 c1   ; compare a1 a2
00000101 ; jump_if_less 指令，后面跟的是 16 位地址
00000110 ; jump，后面跟的是 16 位地址
00000111 ; save_from_register，后面跟的是 16 位地址
; save_from_register 的用法和说明参见下面的例子
11111111 ; halt，停机指令，这个指令会让 CPU 停止执行
; 把这个指令放在程序的最后，CPU 就可以停止了

; 这里我们新增一套操作 16 位数据的指令
00001000 ; set2，用于给寄存器存一个 16 位数字
00001001 ; load2，用于把内存中的一个 16 字节的数字读取到寄存器中
00001010 ; add2，用于把 16 位寄存器相加
00001011 ; save2，用于把 16 位寄存器的数字存到内存地址中，内存地址是 16 位数字
00001100 ; subtract2，用于把 16 位寄存器相减然后保存（具体用法和 add2 一样）
; 例如下面这句相当于 a1 = a1 - a2
; subtract2 a1 a2 a1
00001101 ; load_from_register
; 下面的例子中，假设 a1 是 2，则会把内存地址 2 中的值读取到 a2 寄存器中
; 注意，这个指令只读取 1 字节
; load_from_register a1 a2

00001110 ; load_from_register2
; 下面的例子中，假设 a1 是 100，则会把内存地址 100 中的值读取到 a2 寄存器中
; 注意，这个指令读取 2 字节
; load_from_register2 a1 a2

00001111 ; save_from_register2
; 下面的例子中，假设 a1 是 0xBEAF，a2 是 2
; 由于这个指令保存 2 字节，x16 会使用小端表示法
; 会把内存地址 2 的值设置为 0xAF
; 会把内存地址 3 的值设置位 0xBE
; 后面的所有 16 位数据，我们都会使用小端序，不再说明
; save_from_register2 a1 a2

00010000 ; jump_from_register
; 下面的例子中，假设 a1 中存储的是 20，程序会跳转到 20
; jump_from_register a1




我们对内存的使用做如下约定
把前 1024 字节留空，用于函数调用时暂存信息
所以头 3 个字节(jump 1 字节，后面的地址 2 字节)的指令固定如下，这样 cpu 加载后会从内存 1024 开始执行代码
jump @1024
;
; 从第四个字节开始，剩下的 1021 个字节都是我们的
;
;
;
;
; 下面是内存 1024 开始的内容
; 初始化 f1 寄存器，这是需要我们手动做的
set2 f1 3 ; 设置 f1 寄存器为 3，我们用这个寄存器里的内存地址来保存函数返回后应该跳转的地址
;
; 我们要在接下来的的内存存放函数定义，所以直接跳转到 @function_end 避免执行函数
jump @function_end
;
; 定义一个函数 function_multiply，接受两个参数，返回两个数的乘积
; 参数通过 a1 a2 得到，返回值通过 a1 传给调用方
@function_multiply
set2 a3 2 ; 因为下面用 a2 < a3 做判断，所以 a3 从 2 开始
; 我们需要在循环中把 a3 + 1，并且把 a1 累加
; 由于我们只有 3 个通用寄存器可用，我们需要用 3 个内存来暂存 a1 a2 a3 的值
; 因为我们现在是自主决定使用所有内存，所以我们可以手动指定使用的内存区域
; 我们把 65534 65532 65530 这三个地址拿来存储 a1 a2 a3 的值
; 我们先保存 a1
save2 a1 @65534
@while_start ; 循环开始
compare a2 a3 ;
jump_if_less @while_end ; 一旦 a2 小于 a2，就结束循环
;
; 把 a2 保存到 65532, 然后利用 a2 把 a3+1
save2 a2 @65532
set2 a2 1
add2 a3 a2 a3
;
; 把循环开始之前暂存的 a1 放到 a2 中然后累加到 a1
load2 @65534 a2
add2 a1 a2 a1
;
; 恢复 a2 的值并跳转到循环开始
load2 @65532 a2
jump @while_start
@while_end
; 函数结束了，这时候 a1 存的就是 a1*a2 的值
; f1 寄存器里面存储的是函数调用前的地址，我们让 f1-2，然后把它取出来, 然后返回
set2 a3 2
subtract2 f1 a3 f1
load_from_register2 f1 a2
jump_from_register a2
;
;
; 所有函数定义结束的标记（但我们这个例子中，只有一个函数定义）
@function_end
;
;
; 我们来调用前面的 multiply 函数
set2 a1 300 ; a1 是 300
set2 a2 10 ; a2 是 10
; 保存 pa 到 f1 所表示的内存中
; 请特别注意下面的写法
; save_from_register2 长度是 3 字节
; jump 长度是 3 字节
; set2 add2 各自占用 4 字节
; 所以我们用它们两句之前的 add2 来修正函数返回时候的正确地址(也就是 14)
; cpu 读了 add2 这句后就会把 pa + 4（add2 占用 4 字节）
; 然后才会执行 add2，所以执行 add2 这句的时候只需要把 pa + 6 就能指向 jump @function_multiply 的下一句
set2 a3 14
add2 pa a3 a3
save_from_register2 a3 f1 ; 3 字节
; 保存后，要把 f1 的值 +2
set2 a3 2 ; 4 字节
add2 f1 a3 f1 ; 4 字节
; 跳转到函数
jump @function_multiply ; 3 字节
; 函数返回了，这里的 a1 就是我们想要的返回值
halt

由于我们前面 1024 字节都需要留空，所以我们要增加一个汇编语法来方便生成机器码
具体见下方的简单例子
它实现了 jump 1024 占用前三字节，空 1021 字节

jump @1024
; 下面的 .memory 是一个 x16 汇编标记
; 它表明下面的代码要放到内存 1024 的地方开始
; 汇编器会用 0 填充之间的空余内存
.memory 1024
; 代码











简化版作业7
作业 7


汇编的意义





作业截止时间
周五晚 22:00


交作业方式：
本次作业 7 需要在项目中新建一个 axe7 目录，上交如下文件
axe7/x16asm.py
axe7/x16vm.py

请注意，不要上传多余的文件到仓库，使用 sourcetree 来确保这一点



根据本作业的描述，实现下面两个函数
x16asm.machine_code(asm_code: str)
x16vm.run(memory: List[int])



新的汇编语言资料如下：
我们把 AxePU 升级为 AxePU16（简称 x16）
x16 有如下寄存器
注意，机器码中的寄存器都是用一字节表示的，但是寄存器里面存储的数据是 16 位
00000000    ; pa（program address） 寄存器
00010000    ; a1
00100000    ; a2
00110000    ; a3
01000000    ; c1，保存比较结果的寄存器。0 表示小于，1 表示相等，2 表示大于
01010000    ; f1 寄存器，保存当前寄存器暂存状态的内存地址


我们需要的指令如下
注意，指令也都是用一字节表示的
下面的指令都是操作单字节的，它们作用于寄存器的时候，只会影响寄存器的低 8 位，高 8 位会被清零（高低 8 位怎么模拟你自己定，无所谓，对程序来说它是透明的）
00000000    ; set 指令，用于给寄存器存一个 8 位数字（寄存器高 8 位会清零，以下同理）
00000001    ; load 指令，用于把内存中的一个数字读到寄存器中
00000010    ; add 指令，加的是寄存器低 8 位
00000011    ; save 指令，用手把寄存器的一个数字存到内存地址中，注意这里的内存地址是一个 16 位的数字
00000100    ; compare 指令，用于比较 a1 a2 的大小并且保存结果到 c1
00000101    ; jump_if_less 指令，后面跟的是 16 位地址
00000110    ; jump，后面跟的是 16 位地址
00000111    ; save_from_register，后面跟的是 16 位地址
            ; save_from_register 的用法和说明参见下面的例子
11111111    ; halt，停机指令，这个指令会让 CPU 停止执行
            ; 把这个指令放在程序的最后，CPU 就可以停止了

; 这里我们新增一套操作 16 位数据的指令
00001000    ; set2，用于给寄存器存一个 16 位数字
00001001    ; load2，用于把内存中的一个 16 字节的数字读取到寄存器中
00001010    ; add2，用于把 16 位寄存器相加
00001011    ; save2，用于把 16 位寄存器的数字存到内存地址中，内存地址是 16 位数字
00001100    ; subtract2，用于把 16 位寄存器相减然后保存（具体用法和 add2 一样）
            ; 例如下面这句相当于 a1 = a1 - a2
            ; subtract2 a1 a2 a1
00001101    ; load_from_register
            ; 下面的例子中，假设 a1 是 2，则会把内存地址 2 中的值读取到 a2 寄存器中
            ; 注意，这个指令只读取 1 字节
            ; load_from_register a1 a2
00001110    ; load_from_register2
            ; 下面的例子中，假设 a1 是 100，则会把内存地址 100 中的值读取到 a2 寄存器中
            ; 注意，这个指令读取 2 字节
            ; load_from_register2 a1 a2
00001111    ; save_from_register2
            ; 下面的例子中，假设 a1 是 0xBEAF，a2 是 2
            ; 由于这个指令保存 2 字节，x16 会使用小端表示法
            ; 会把内存地址 2 的值设置为 0xAF
            ; 会把内存地址 3 的值设置位 0xBE
            ; 后面的所有 16 位数据，我们都会使用小端序，不再说明
            ; save_from_register2 a1 a2
00010000    ; jump_from_register
            ; 下面的例子中，假设 a1 中存储的是 20，程序会跳转到 20
            ; jump_from_register a1



作业 7.1
通过讨论，弄明白新增的指令的意义
先为每条指令单独写测试
然后再写一套可以完整地测试不同指令的测试











我们对内存的使用做如下约定
把前 1024 字节留空，用于函数调用时暂存信息
所以头 3 个字节(jump 1 字节，后面的地址 2 字节)的指令固定如下，这样 cpu 加载后会从内存 1024 开始执行代码
jump @1024
    ;
    ; 从第四个字节开始，剩下的 1021 个字节都是我们的
    ;
    ;
    ;
    ;
    ; 下面是内存 1024 开始的内容
    ; 初始化 f1 寄存器，这是需要我们手动做的
set2 f1 3   ; 设置 f1 寄存器为 3
            ; 我们用这个寄存器里的内存地址来保存函数返回后应该跳转的地址
            ; 内存地址为 3 4 的两个字节分别存储了一个 16 位地址的低 8 位和高 8 位
    ;
    ; 我们要在接下来的的内存存放函数定义，所以直接跳转到 @function_end 避免执行函数
jump @function_end



    ; 我们先把高级语言代码写出来，再翻译为汇编
    ; 由于我们的指令只有 jump_if_great
    ; 所以代码的逻辑要写大于
def multiply(a, b)
    s = 0
    i = 0
    while b > i:
        s += a
        i += 1
    return s


    ; 定义一个函数 function_multiply，接受两个参数，返回两个数的乘积
    ; 参数通过 a1 a2 得到，返回值通过 a1 传给调用方
@function_multiply

        ; a1 a2 是参数，我们把他们存进内存中
        ; 我们用 65534 65532 65530 这三个地址拿来存储 a1 a2 a3 的值
        ; 为了方便大家看懂
        ; 我们在下面的代码中使用 @a @b @s @i 的方式来替代具体的内存地址
    save2 a1 @a
    save2 a2 @b
        ; 我们用 65528 这个地址来存 s
    set2 a1 0
    save2 a1 @s

        ; 我们用 a3 来作为变量 i
        ; 这里我们没有把变量 i 放到内存中去存储
        ; 你可以扩展这里，让 i 存到内存中去
    set2 a3 0

        ; 开始 while 循环
    @while_start
            ; 把之前暂存的变量 b 载入 a1
        load2 a1 @b
        compare a1 a3
            ; 下面两个跳转很重要
        jump_if_great @while_block
        jump @while_end

    @while_block
        ; s += a
        load2 a1 @s
        load2 a2 @a
        add2 a1 a2 a1
        save2 a1 @s
        ;
        ; i += 1
        set2 a1 1
        add2 a1 a3 a3
        jump @while_start
    @while_end

        ; 函数结束了，这时候 @s 内存存的就是 a1*a2 的值
        ; 我们把它加载到 a1 寄存器中
    load2 a1 @s

        ; 内存 f1-2 里面存储的是函数调用前保存的下一条指令的地址
        ; 我们把它取出来, 然后跳转返回
    set2 a3 2
    subtract2 f1 a3 f1

    load_from_register2 f1 a2
    jump_from_register a2


    ; 所有函数定义结束的标记（但我们这个例子中，只有一个函数定义）
@function_end




作业 7.2
改写上面的代码，让 i 变量存到内存中去
搞懂函数是怎么返回的















    ; 我们来调用前面的 multiply 函数
set2 a1 300     ; a1 是 300
set2 a2 10      ; a2 是 10

    ; 保存 pa 到 f1 所表示的内存中
    ; 请特别注意下面的写法
    ; save_from_register2 长度是 3 字节
    ; jump 长度是 3 字节
    ; set2 add2 各自占用 4 字节
    ; 所以我们用它们两句之前的 add2 来修正函数返回时候的正确地址(也就是 14)
    ; cpu 读了 add2 这句后就会把 pa + 4（add2 占用 4 字节）
    ; 然后才会执行 add2，所以执行 add2 这句的时候只需要把 pa + 6 就能指向 jump @function_multiply 的下一句
set2 a3 14
add2 pa a3 a3
save_from_register2 a3 f1   ; 3 字节
    ; 保存后，要把 f1 的值 +2
set2 a3 2                   ; 4 字节
add2 f1 a3 f1               ; 4 字节
    ; 跳转到函数
jump @function_multiply     ; 3 字节
    ; 函数返回了，这里的 a1 就是我们想要的返回值
halt






作业 7.3
把函数调用的代码搞懂













由于我们前面 1024 字节都需要留空，所以我们要增加一个汇编语法来方便生成机器码
具体见下方的简单例子
它实现了 jump 1024 占用前三字节，空 1021 字节

jump @1024
    ; 下面的 .memory 是一个 x16 汇编标记
    ; 它表明下面的代码要放到内存 1024 的地方开始
    ; 汇编器会用 0 填充之间的空余内存
.memory 1024
    ; 代码





作业 7.4
搞懂 .memory 是在做什么
实现 .memory 的功能

